#!/usr/bin/env python
# license removed for brevity

import rospy
import actionlib
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from geometry_msgs import PoseStamped, Pose, Point, Quaternion, Twist
from tf.transformations import quaternion_from_euler



class PoseXYT:
    def __init__(self, x, y, th):
        self.x = x
        self.y = y
        self.th = th

class DeviceGoal:
    def __init__(self, device, state, pose):
        self.device = device
        self.state = state
        self.pose = pose

class DeviceManipulator:
    def __init__(self):
        self.p_x = 10
        self.i_x = 10
        self.d_x = 10
        self.p_y = 10
        self.i_y = 10
        self.d_y = 10

        self.done = False

        self.thresh_error = 0.1

        self.base_pub = rospy.Publisher('cmd_vel', Twist, queue_size = 1)
        
        # cmd_arm
        # x horizontal actuator
        # y stepper motor
        # z vertical actuator
        self.arm_pub = rospy.Publisher('cmd_arm', Point, queue_size = 1) 

        # cmd_arm
        # x horizontal error
        # y vertical error
        # z valve angle
        self.sub = rospy.Subscriber("/device_pos", Point, self.deviceAlignCallback)
    
    def deviceAlignCallback(self, data):
        pos = data.data
        x = pos.x
        y = pos.y
        self.th = pos.z

        error_x = x - self.desired_x
        error_y = y - self.desired_y

        if self.done or (error_x < self.thresh_error 
                    and error_y < self.thresh_error):
            self.done = True
            return

        self.sum_error_x = self.sum_error_x + error_x
        self.sum_error_y = self.sum_error_y + error_y

        derivative_error_x = error_x - self.prev_error_x
        derivative_error_y = error_y - self.prev_error_y

        self.prev_error_x = error_x
        self.prev_error_y = error_y

        twist_base = Twist()
        twist_arm = Twist()

        twist_base.y = error_x*self.p_x + self.sum_error_x*self.i_x + derivative_error_x*self.d_x
        twist_arm.z = error_y*self.p_y + self.sum_error_y*self.i_y + derivative_error_y*self.d_y

        self.base_pub.publish(twist_base)
        self.arm_pub.publish(twist_arm)
        

    def manipulate(self, device, desired_x, desired_y, desired_th):
        self.device = device
        self.desired_x = desired_x
        self.desired_y = desired_y
        self.desired_th = desired_th

        self.prev_error_x = 0
        self.prev_error_y = 0

        self.sum_error_x = 0
        self.sum_error_y = 0

        self.done = False

        rate = rospy.Rate(10)
        while not self.done:
            rate.sleep()
        

        
        

def navigation_client(x, y , th):

    client = actionlib.SimpleActionClient('move_base',MoveBaseAction)
    client.wait_for_server()

    goal = MoveBaseGoal()
    goal.target_pose.header.frame_id = "map"
    goal.target_pose.header.stamp = rospy.Time.now()

    position = Point()
    position.x = x
    position.y = y
    position.z = 0

    goal.target_pose.pose.position = position
    goal.target_pose.pose.orientation = Quaternion(quaternion_from_euler(0, 0, th)) ############

    client.send_goal(goal)
    wait = client.wait_for_result()
    if not wait:
        rospy.logerr("Action server not available!")
        rospy.signal_shutdown("Action server not available!")
    else:
        return client.get_result()

if __name__ == '__main__':
    try:
        rospy.init_node('shipbot_client')
        aligner = DeviceManipulator()
        # Parse commands
        deviceGoals = []
        for deviceGoal in deviceGoals:
                result = navigation_client(deviceGoal.x, deviceGoal.y, deviceGoal.th)
                if result:
                    rospy.loginfo("Goal execution done!")
                    
                else:
                    rospy.loginfo("Goal execution not complete!")
        

    except rospy.ROSInterruptException:
        rospy.loginfo("Client Closed")
    rospy.loginfo("Navigation Finished")